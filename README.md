# Описание eventbus

Это in-memory сервис, реализующий паттерн **Publish–Subscribe** поверх gRPC. Клиенты могут подписываться на события по ключу и публиковать новые события, которые моментально раздаются всем активным подписчикам.

- **gRPC слой** (`internal/grpc`)  
    — оборачивает метод `Subscribe` и `Publish` над нашей шиной.  
- **In-Memory Broker** (`internal/service`)  
    — хранит подписчиков, распределяет сообщения по FIFO-очереди, поддерживает `Close(ctx)` с учётом `context.Context`.  
- **Конфигурация** (`config` + Viper)  
    — все параметры (порт, размер буфера, таймаут, логирование) настраиваются через `config/config.yaml`.  
- **Логирование** (Zap)  
    — структурированные логи в `json` или консольном формате.  
- **Graceful shutdown**  
    — на SIGINT/SIGTERM сначала останавливается gRPC (`GracefulStop`), затем шина ожидает доставки всех сообщений, и не дольше `shutdown_timeout`.  
- **Middleware** (`internal/middleware`)  
    — gRPC-интерсепторы для логирования начала/конца каждого RPC.

## Конфигурация проекта

Для демонстрации работы используется конфигурационный файл:
`config/config.yaml`

В нем указать:
- порт 
- размер буфера 
- таймаут 
- способ логирования( `json` или `console`)
- путь до файла с логами(если оставить пустым, то вывод будет в консоль, независимо от указанного способа логирования)

## Запуск проекта

0. go install github.com/go-task/task/v3/cmd/task@latest

1. Установить зависимости:

```shell
task bin-deps
```

2. Забилдить:

```shell
task build
```

3. Сгенерировать pb

```shell
task grpc
```

4. Запустить сервер:

```shell
task serve
```

## Интеграционные тесты

Дополнительно были написаны интеграционные тесты для проверки работы всего стека:

- Поднимают in-memory gRPC-сервис

- Выполняют rpc Subscribe, потом Publish

- Читают стрим и проверяют, что подписчик получил все сообщения, в том числе при высокой нагрузке

Для запуска интеграционный тестов 

```shell
task e2e
```

### Ручками

Можно вручную с помощью `grpcurl`

1. Сначала подписаться

```shell
grpcurl -plaintext \
  -import-path . \
  -proto proto/service.proto \
  -d '{"key":"orders"}' \
  localhost:50052 \
  eventbus.PubSub/Subscribe
```

2. Публиковать

```shell
grpcurl -plaintext \
  -import-path . \
  -proto proto/service.proto \
  -d '{"key":"orders","data":"bebra"}' \
  localhost:50052 \
  eventbus.PubSub/Publish
```

## Taskfile

Помимо запуска Taskfile предоставляет различный функционал. К примеру запуск тестов:

```shell
task test
```

Также можно получить процент покрытия тестами(в первой части задания составляет 100%):


```shell
task coverage
```

Полный функционал с описанием можно увидеть после ввода команды:

```shell
task help
```

### Про паттерны

- **DI**
    — Передача `SubPub`-брокера и `zap.Logger` в gRPC-слой
- **Graceful Shutdown**
    — `grpcServer.GracefulStop()` + `bus.Close(ctx)`
- **Middleware**
    — gRPC-интерсепторы для логирования начала и конца каждого RPC (Unary и Stream)
- **Потокобезопасная очередь**
    — Брокер хранит мапу(словарь) подписчиков под sync.RWMutex, сообщения передаются по буферизированным каналам.
- **Отмена по контексту**
    — Все долгоживущие операции проверяют <-ctx.Done() и прекращают работу мгновенно при отмене.


